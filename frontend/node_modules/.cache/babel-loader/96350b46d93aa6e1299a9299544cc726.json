{"ast":null,"code":"/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n'use strict';\n\nimport * as utils from '../utils.js';\nexport { shimGetUserMedia } from './getusermedia';\nexport { shimGetDisplayMedia } from './getdisplaymedia';\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n\n        this.addEventListener('track', this._ontrack = f);\n      },\n\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = e => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n\n      return e;\n    });\n  }\n}\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function (pc, track) {\n      return {\n        track,\n\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n\n          return this._dtmf;\n        },\n\n        _pc: pc\n      };\n    }; // augment addTrack when getSenders is not available.\n\n\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n\n          this._senders.push(sender);\n        }\n\n        return sender;\n      };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n\n        const idx = this._senders.indexOf(sender);\n\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n\n        if (sender) {\n          // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n\n        return this._dtmf;\n      }\n\n    });\n  }\n}\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments; // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    } // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n\n\n    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function (response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n      return standardReport;\n    }; // shim getStats with maplike support\n\n\n    const makeMapStats = function (stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function (response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_, selector]);\n    } // promise-support\n\n\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [function (response) {\n        resolve(makeMapStats(fixChromeStats_(response)));\n      }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  } // shim sender stats.\n\n\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n      /* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */\n      utils.filterStats(result, sender.track, true));\n    };\n  } // shim receiver stats.\n\n\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result => utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  } // shim RTCPeerConnection.getStats(track).\n\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n\n        return r.track === track;\n      });\n\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n\n    return origGetStats.apply(this, arguments);\n  };\n}\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n\n    return sender;\n  };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  } // shim addTrack and removeTrack.\n\n\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  } // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n\n\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    }); // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n\n    const streams = [].slice.call(arguments, 1);\n\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track); // Trigger ONN async.\n\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n\n    return this.getSenders().find(s => s.track === track);\n  }; // replace the internal stream id with the external one and\n  // vice versa.\n\n\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [description => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, err => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\n      }\n\n    };\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  }; // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n\n      if (description.type === '') {\n        return description;\n      }\n\n      return replaceInternalStreamId(this, description);\n    }\n\n  });\n\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    } // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n\n\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n\n    const isLocal = sender._pc === this;\n\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    } // Search for the native stream the senders track belongs to.\n\n\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\n\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n\n  if (!window.RTCPeerConnection) {\n    return;\n  } // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n\n\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n} // Attempt to fix ONN in plan-b mode.\n\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n\n    return e;\n  });\n}","map":{"version":3,"names":["utils","shimGetUserMedia","shimGetDisplayMedia","shimMediaStream","window","MediaStream","webkitMediaStream","shimOnTrack","RTCPeerConnection","prototype","Object","defineProperty","get","_ontrack","set","f","removeEventListener","addEventListener","enumerable","configurable","origSetRemoteDescription","setRemoteDescription","_ontrackpoly","e","stream","te","receiver","getReceivers","find","r","track","id","event","Event","transceiver","streams","dispatchEvent","getTracks","forEach","apply","arguments","wrapPeerConnectionEvent","value","shimGetSendersWithDtmf","shimSenderWithDtmf","pc","dtmf","_dtmf","undefined","kind","createDTMFSender","_pc","getSenders","_senders","slice","origAddTrack","addTrack","sender","push","origRemoveTrack","removeTrack","idx","indexOf","splice","origAddStream","addStream","origRemoveStream","removeStream","s","RTCRtpSender","origGetSenders","senders","shimGetStats","origGetStats","getStats","selector","onSucc","onErr","length","fixChromeStats_","response","standardReport","reports","result","report","standardStats","timestamp","type","localcandidate","remotecandidate","names","name","stat","makeMapStats","stats","Map","keys","map","key","successCallbackWrapper_","Promise","resolve","reject","then","shimSenderReceiverGetStats","RTCRtpReceiver","filterStats","origGetReceivers","receivers","srcElement","MediaStreamTrack","err","DOMException","shimAddTrackRemoveTrackWithNative","getLocalStreams","_shimmedLocalStreams","streamId","alreadyExists","existingSenders","newSenders","filter","newSender","concat","shimAddTrackRemoveTrack","browserDetails","version","origGetLocalStreams","nativeStreams","_reverseStreams","_streams","newStream","signalingState","call","t","oldStream","replaceInternalStreamId","description","sdp","internalId","externalStream","internalStream","replace","RegExp","RTCSessionDescription","replaceExternalStreamId","method","nativeMethod","methodObj","args","isLegacyCall","desc","origSetLocalDescription","setLocalDescription","origLocalDescription","getOwnPropertyDescriptor","isLocal","streamid","hasTrack","shimPeerConnection","webkitRTCPeerConnection","RTCIceCandidate","fixNegotiationNeeded","target","getConfiguration","sdpSemantics"],"sources":["/Users/diaskywashi/Desktop/pettochat/frontend/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js"],"sourcesContent":["/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\n\nexport {shimGetUserMedia} from './getusermedia';\nexport {shimGetDisplayMedia} from './getdisplaymedia';\n\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 ||\n        typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_,\n        selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [\n        function(response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\n\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n      .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n          this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n          externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n          internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n      .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n      window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n      'localDescription', {\n        get() {\n          const description = origLocalDescription.get.apply(this);\n          if (description.type === '') {\n            return description;\n          }\n          return replaceInternalStreamId(this, description);\n        }\n      });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || (pc.getConfiguration &&\n        pc.getConfiguration().sdpSemantics === 'plan-b')) {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}